<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | (think)]]></title>
  <link href="http://bbatsov.github.com/articles/categories/ruby/atom.xml" rel="self"/>
  <link href="http://bbatsov.github.com/"/>
  <updated>2012-09-09T21:45:57+03:00</updated>
  <id>http://bbatsov.github.com/</id>
  <author>
    <name><![CDATA[Bozhidar Batsov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby Tip #2: Get a List of All Rake Tasks]]></title>
    <link href="http://bbatsov.github.com/articles/2012/03/08/ruby-tip-number-2-get-a-list-of-all-rake-tasks/"/>
    <updated>2012-03-08T15:28:00+02:00</updated>
    <id>http://bbatsov.github.com/articles/2012/03/08/ruby-tip-number-2-get-a-list-of-all-rake-tasks</id>
    <content type="html"><![CDATA[<p>Many people are having trouble remembering all the rake tasks defined
in a particular project's <code>Rakefile</code> (especially if they hadn't
authored it). This is quite normal given the fact that Rails's
Rakefile, for instance, defines 39 tasks (as of version
3.2.2). Personally I never memorize anything, but the most basic rake
tasks - for everything else there is the <code>rake -T</code> (or <code>rake --tasks</code>)
command. Here's the command in action for Octopress's Rakefile:</p>

<p><code>bash
$ rake -T
rake clean                 # Clean out caches: .pygments-cache, .gist-cache, .sass-cache
rake copydot[source,dest]  # copy dot files for deployment
rake deploy                # Default deploy task
rake gen_deploy            # Generate website and deploy
rake generate              # Generate jekyll site
rake install[theme]        # Initial setup for Octopress: copies the default theme into the path of Jekyll's generator.
rake integrate             # Move all stashed posts back into the posts directory, ready for site generation.
rake isolate[filename]     # Move all other posts than the one currently being worked on to a temporary stash location (stash) so regenerating the site happens much quicker.
rake list                  # list tasks
rake new_page[filename]    # Create a new page in source/(filename)/index.markdown
rake new_post[title]       # Begin a new post in source/_posts
rake preview               # preview the site in a web browser
rake push                  # deploy public directory to github pages
rake rsync                 # Deploy website via rsync
rake set_root_dir[dir]     # Update configurations to support publishing to root or sub directory
rake setup_github_pages    # Set up _deploy folder and deploy branch for Github Pages deployment
rake update_source[theme]  # Move source to source.old, install source theme updates, replace source/_includes/navigation.html with source.old's navigation
rake update_style[theme]   # Move sass to sass.old, install sass theme updates, replace sass/custom with sass.old/custom
rake watch                 # Watch the site and regenerate when it
changes
</code></p>

<p>Not only did you get a list of all the tasks, but nice descriptions of
the tasks as well.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Tip #1: Demystifying the Difference Between == and eql?]]></title>
    <link href="http://bbatsov.github.com/articles/2011/11/28/ruby-tip-number-1-demystifying-the-difference-between-equals-equals-and-eql/"/>
    <updated>2011-11-28T16:54:00+02:00</updated>
    <id>http://bbatsov.github.com/articles/2011/11/28/ruby-tip-number-1-demystifying-the-difference-between-equals-equals-and-eql</id>
    <content type="html"><![CDATA[<p>Newcomers to Ruby are often confused by the fact the <code>Object</code> class
defines three methods related to equality - <code>==</code>, <code>eql?</code> and
<code>equals?</code>. Of the three the one that it's easiest to describe is
<code>equal?</code> - it implements what's commonly known as reference equality
check. The method returns <code>true</code> only if its receiver (the object upon
the method was invoked) and parameter (the object we're comparing to) are
the same object (Java developers should think of the <code>==</code> operator
there).</p>

<p>``` ruby
some_word = "word"
some_other_word = some_word</p>

<p>some_word.equals? some_other_word # true
```</p>

<p>Both <code>==</code> and <code>eql?</code> implement value equality checks - they are not
interested in whether two variables point to the same object in
memory, but whether two objects are equal in terms of their
values. For instance "cat" and "cat" might very well be two completely
different <code>String</code> objects, but they are quite obviously the same as
far as their value is concerned.</p>

<p><code>ruby
"cat".equals? "cat"    # false
"cat" == "cat"         # true
"cat".eql? "cat"       # true
</code></p>

<p>What's not immediately obvious is why are there two different
methods that seem to be doing exactly the same thing. The answer is
simple - <code>eql?</code> is meant to be used as a stricter version of <code>==</code>, if
there is a need for such stricter version.<code>eql?</code> most prominent usage
is probably in the <code>Hash</code> class, where it's used to test members for equality.</p>

<p>In the <code>Object</code> class <code>eql?</code> is synonym with <code>==</code>. Most subclasses
continue this tradition, but there are a few classes that provide a
different implementation for <code>eql?</code>.  Numeric types, for example,
perform type conversion across <code>==</code>, but not across <code>eql?</code>, so:</p>

<p><code>ruby
1 == 1       # true
1.eql? 1     # true
1 == 1.0     # true
1.eql? 1.0   # false
1.0.eql? 1.0 # true
</code></p>

<p>As you can see clearly from this example - <code>eql?</code> for <code>Numeric</code> classes
requires both objects to be instances of the same class, apart from
having equal values, to return <code>true</code>.</p>

<p>If you're wondering about the origins of that convention I should probably
refer you to Common Lisp (one of the languages cited as principle
inspiration for Ruby). Common Lisp has <a href="http://eli.thegreenplace.net/2004/08/08/equality-in-lisp/">quite a few equality
predicates</a>,
dealing with various aspects of equality. I guess I never found <code>==</code>
and <code>eql?</code> in Ruby particularly confusing, because I knew Common Lisp,
before I started playing around with Ruby.</p>

<p>Hopefully, I've managed to make the difference between <code>==</code> and <code>eql?</code>
clear. That's some fairly esoteric matter that's not totally
understood by even some fairly experienced Ruby developers.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Admin Interfaces for Rails Apps: RailsAdmin vs ActiveAdmin]]></title>
    <link href="http://bbatsov.github.com/articles/2011/11/20/admin-interfaces-for-rails-apps-railsadmin-vs-activeadmin/"/>
    <updated>2011-11-20T09:24:00+02:00</updated>
    <id>http://bbatsov.github.com/articles/2011/11/20/admin-interfaces-for-rails-apps-railsadmin-vs-activeadmin</id>
    <content type="html"><![CDATA[<h2>Prelude</h2>

<p>Often in comparisons between <a href="https://www.djangoproject.com/">Django</a>
and Rails, one of the Django advantages being cited is the automatic
admin interface you get for free out-of-the-box there.</p>

<p>I guess a lot of people don't know that there are similar solutions for
Rails, although they are not included in the standard
distribution. Currently the two most prominent admin UI 'frameworks' are
<a href="https://github.com/sferik/rails_admin">RailsAdmin</a> and <a href="http://activeadmin.info/">Active Admin</a>.</p>

<p>While they are both shooting to solve the same problem, they do it in
a very different way. Many new users are quite confused what
advantages/disadvantages one has over the other (and vice versa) and
that's the reason I'm writing this article right now - to clarify a
few vague points and to help people choose the framework most
appropriate for the task at hand.</p>

<!--more-->


<h2>RailsAdmin</h2>

<p>RailsAdmin started its life as a port of MerbAdmin to Rails 3 and was
implemented as a Ruby Summer of Code project by Bogdan Gaza with
mentors Erik Michaels-Ober, Yehuda Katz, Luke van der Hoeven, and Rein
Henrichs. The project is self described as <em>a Rails
engine that provides an easy-to-use interface for managing your
data.</em>.</p>

<p>Its main features include:</p>

<ul>
<li>Display database tables</li>
<li>Create new data</li>
<li>Easily update data</li>
<li>Safely delete data</li>
<li>Automatic form validation</li>
<li>Search and filtering</li>
<li>Export data to CSV/JSON/XML (very handy)</li>
<li>Authentication (via Devise)</li>
<li>User action history</li>
</ul>


<p>RailsAdmin currently supports only ActiveRecord as the ORM. You can
see a live demo of RailsAdmin <a href="http://rails-admin-tb.herokuapp.com/">here</a>.</p>

<p>The current master branch of RailsAdmin targets Rails 3.1.x and it's
naturally aware of the asset pipeline introduced there. Installing
RailsAdmin is a trivial exercise. Just add these deps to your
<code>Gemfile</code>:</p>

<p><code>ruby
gem 'fastercsv' # Only required on Ruby 1.8 and below
gem 'rails_admin', :git =&gt; 'git://github.com/sferik/rails_admin.git'
</code></p>

<p>Afterwards you should run:</p>

<p><code>bash
$ bundle install
$ rails g rails_admin:install
$ rake db:migrate
</code></p>

<p>And you're done. RailsAdmin uses internally the tried and true
<a href="https://github.com/plataformatec/devise">Devise</a> for admin users authentication. If you're already using
devise - you're covered, otherwise RailsAdmin will install it for you.</p>

<p>At this point you can boot your development web server (<code>rails s</code>) and
visit the url <a href="http://localhost:3000/admin">localhost:3000/admin</a> (or whatever port you're running
the dev server on). You'll be able to create admin accounts and after
you log in you'll be presented by an attractive admin dashboard, that
shows you an overview of all the tables in your model.</p>

<p>By default you'll be able to manage every single model in your
app. You'll have to customize the contents of
<code>config/initializers/rails_admin.rb</code> to change that default
behavior.</p>

<p>One thing to note is that there are no gem releases of
RailsAdmin. It's still alpha quality software (at least on paper - it's
quite stable actually). I'm generally a bit annoyed to have to track
gems from a git repo, but I understand and respect the developer's
decision on the matter. Hopefully we'll see a stable release of
RailsAdmin soon enough and a gem to go with it.</p>

<p>Another thing to keep in mind is the use case for RailsAdmin - it is
pretty much an automatic backend, that you're not supposed to modify a
lot. In its spirit it's very close to what Django's admin backend
is. RailsAdmin is very smart in determining the relations between
model and supplying forms and show views that express them properly.</p>

<p>Unfortunately not all relationships are represented correctly and
modifying the form builders in RailsAdmin is no walk in the
park. Another minor annoyance is that CarrierWave is not supported out
of the box so you have to do some manual tinkering in the RailsAdmin
initializer to make it work.</p>

<p>Some of the nicer touches in RailsAdmin include basic integration with
CKEditor (a rich WYSIWYG editor) and an user action feature, which
helps keep track of who did what. I wouldn't mind seeing some mention of
TinyMCE as an alternative to CKEditor in the docs, since it's considered more
robust by many (yours truly included).</p>

<p>The docs themselves are just a big README in the project's github
repo. While they feature most of what you'll need to know about
RailsAdmin, having them organized in a nicer way (something that the
guys behind Active Admin have done) wouldn't hurt.</p>

<h2>Active Admin</h2>

<p>Active Admin is the other big Rails admin UI framework, developed by
Greg Bell. Its official web site describes it like this:</p>

<p><blockquote><p>Active Admin is a Ruby on Rails plugin for generating administration<br/>style interfaces. It abstracts common business application patterns to<br/>make it simple for developers to implement beautiful and elegant<br/>interfaces with very little effort.</p></blockquote></p>

<p>Active Admin is of course Rails 3.1 ready, plays nice with the asset
pipeline and has great documentation on its official web site. There
also a very nice <a href="http://railscasts.com/episodes/284-active-admin">introductory screencast</a> by Ryan Bates from RailsCasts.</p>

<p>Getting started with Active Admin is just as easy as getting started
with RailsAdmin. You just need to add a dependency to your <code>Gemfile</code>:</p>

<p><code>ruby
gem 'activeadmin'
</code></p>

<p>And to a few command line incantations afterwards to seal the deal:</p>

<p><code>bash
$ bundle install
$ rails g active_admin:install
$ rake db:migrate
$ rails s
</code></p>

<p>Fire up your favorite browser and visit
<a href="http://localhost:3000/admin">localhost:3000/admin</a>. The default username is
<em>admin@example.com</em> and the default password is <em>password</em>. You'd
probably be surprised to see an empty dashboard and absolutely no
models that you can administer. Active Admin takes a totally different
approach compared to RailsAdmin. Here nothing happens automatically -
you have to customize your dashboard yourself and you have to register
the models you'd be administrating with the following command:</p>

<p><code>bash
$ rails g active_admin:resource ModelName
</code></p>

<p>This will create a file named <code>app/admin/model_name.rb</code> where you can
tinker with looks of the resource's index, form and show view.</p>

<p>And here comes Active Admin's core feature - it's immensely easy to
customize anything in the Admin UI. The forms used to create and
update model records are simple Formtastic forms (the same Formtastic
forms you're probably already using throughout the rest of your
apps):</p>

<p>``` ruby
ActiveAdmin.register Post do
  form do |f|</p>

<pre><code>f.inputs "Details" do
  f.input :title
  f.input :published_at, :label =&gt; "Publish Post At"
  f.input :category
end
f.inputs "Content" do
  f.input :body
end
f.buttons
</code></pre>

<p>  end
end
```</p>

<p>Rendering a partial for the form is also supported.</p>

<p>Active Admin features an elegant DSL to express the index and the show
views. Here's an example of index table for a fictional Course
Management app:</p>

<p>``` ruby
ActiveAdmin.register Course do
  index do</p>

<pre><code>column :id
column :title
column :start_date
column :end_date
column :created_at
column :updated_at
default_actions
</code></pre>

<p>  end
end
```</p>

<p>The <code>default_actions</code> method invocation here is important - without it
you'll be missing the action buttons in the last column of the index
table.</p>

<p>Here's an example of a show view:</p>

<p>``` ruby
ActiveAdmin.register Post do
  show do</p>

<pre><code>h3 post.title
div do
  simple_format post.body
end
</code></pre>

<p>  end
end
```</p>

<p>Alternatively you can forgo the Arbre HTML DSL and render a partial like this:</p>

<p>``` ruby
ActiveAdmin.register Post do
  show do</p>

<pre><code># renders app/views/admin/posts/_some_partial.html.erb
render "some_partial"
</code></pre>

<p>  end
end
```</p>

<p>The documentation is very well written and quite extensive so I
wouldn't go into many details here (remember DRY). The only issue I've
had with Active Admin so far is not related to Active Admin directly -
the latest gem release still depends on the old Formtastic 1.3 and I
happen to use Formtastic 2.0 in all of my apps. Luckily the master
branch is already using Formtastic 2.0, so all you have to do if you
have this problem is to use the gem from git:</p>

<p><code>ruby
'activeadmin', git: git://github.com/gregbell/active_admin.git
</code></p>

<p>If you're reading this article after the release of Active Admin 0.4
(which should happen any day now) - you don't have to do this.</p>

<h2>Which Should You Use</h2>

<p>The answer to that question depends on your needs for a particular
project.</p>

<p>RailsAdmin is still alpha. Unstable developments are made in topic branches
and master is supposed to be as stable as possible. RailsAdmin is not an admin scaffolder as is
Active Admin. It's an automatic backend. It's goal is to provide a full
access to your data, with maximum of defaults extracted from
application's ORM/ActiveModel, a DSL to customize those, and hooks for
third-party projects (Cancan/Devise/Paperclip/CKeditor) to enrich the
experience. Granularity is
higher in RA. You are not supposed to access FormBuilder the way you
would with Active Admin and Formtastic. RailAdmin says here <em>It's in the dev field, not
configuration</em>. Still, the current blackbox has some flaws, discrepancies
and uncovered areas that its developers are currently addressing.</p>

<p>Active Admin basically does things the other way around. You're
totally supposed to tweak every aspect of the Admin UI - but tweaking
those aspects is very very easy. If you're looking for a heavily
customized Admin UI solution - Active Admin is certainly the way to
go. It's not an automatic admin backend by any means - it's more or
less a framework that simplifies the creation of admin UIs.</p>

<p>In terms of popularity it seems that RailsAdmin is a bit more popular
right now. I consider the GitHub watchers of a project to be a fairly
accurate measurement of its popularity and as of the time of this
writing RailsAdmin has 2539 compared to 2127 for Active Admin. You
have to consider the fact that RailsAdmin has been out in the open a
bit longer. Active Admin is rapidly closing this gap, however, and I
expect it to surpass RailsAdmin in a month or two.</p>

<p>My personal recommendation is to start by trying RailsAdmin - if it
covers your use cases, you'd do well to simply use it instead of
pouring additional effort into creating a similar UI with Active
Admin. If you need heavily customized admin UI, however, you'd
probably do well to start with Active Admin in the first place, since
after all - it was designed for such scenarios.</p>

<h2>Epilogue</h2>

<p>Having used both RailsAdmin and Active Admin with real projects I can
tell you that they serve a different purpose - the
admin UI generated by RailsAdmin is quite usable by default and might
be used with very little changes. Active Admin's admin UI generally
requires manual tweaking to achieve the same effect. On the other hand
Active Admin was developed with manual customization in mind at it's
very easy to do such changes there. Modifying the forms in RailsAdmin
was definitely a less pleasant experience (not to mention stuff like
CarrierWave integration).</p>

<p>While there are some people urging the projects to merge I think that
would be a terrible idea. Aside from the technical difficulties of
merging separate projects sharing no common codebase, I do think diversity
matters. Rails has virtually no alternatives (in Rubyland) and that is bad for
business, since competition always drives innovation. I'd love to see
both projects evolve in their current directions (and stabilize along
the way).</p>

<p>So what are you waiting for? Give them both a shot and share your
experience in the comments section! :-)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deploying Rails 3.1 applications on Heroku's Celadon Cedar stack]]></title>
    <link href="http://bbatsov.github.com/articles/2011/10/30/deploying-rails31-apps-on-celadon-cedar/"/>
    <updated>2011-10-30T00:00:00+03:00</updated>
    <id>http://bbatsov.github.com/articles/2011/10/30/deploying-rails31-apps-on-celadon-cedar</id>
    <content type="html"><![CDATA[<h2>Prelude</h2>

<p><a href="http://heroku.com">Heroku</a> is an amazing cloud hosting solution. It's extremely well
documented, very easy to start with, very stable and provides you with
the option to use free hosting for some small applications.</p>

<p>While Heroku is generally known as a Ruby on Rails hosting company,
since their acquisition by SalesForce last year, they've expanded
their deployment options a lot. Currently Ruby, Java, Scala, Clojure,
Python and Node.js are all officially supported (on the Cedar Celadon
stack) and more will probably come very soon.</p>

<p>All of our company's applications are using
<a href="http://guides.rubyonrails.org/">Ruby on Rails 3.1.x</a> and are
targeting the <a href="http://ruby-lang.org">MRI 1.9.2</a>. Those two facts are
the reason that we're using Heroku's
<a href="http://devcenter.heroku.com/articles/cedar">Celadon Cedar</a> deployment
stack. Celadon Cedar is currently in beta, but it offer a lot of
benefit over the old (stable) Bamboo stack (which also support Rails
3.1 apps and Ruby 1.9.2). For instance - Celadon is aware of the Rails
3.1 asset pipeline and can compile the assets automatically when you
deploy your apps to Heroku. With Bamboo you have to precompile the
resources, which is a very tedious task.</p>

<p>While our experience with Heroku has been very positive in
general, we've hit some bumps along the road, so I've decided to share
some of the problems and their solutions with everyone.</p>

<!--more-->


<h2>Background</h2>

<p>There are some things to keep in mind before deploying to Heroku:</p>

<ul>
<li><p>You can't upload files to Heroku. This means that if you're using a
gem such as <a href="https://github.com/jnicklas/carrierwave">CarrierWave</a> (or
<a href="https://github.com/thoughtbot/paperclip">PaperClip</a>) for file uploads
it should be configured to use some cloud storage (e.g. Amazon
S3). There is only one writeable folder on Heroku and this is the
<strong>tmp</strong> folder that you should configure as a tmp folder for your
uploads as well.</p></li>
<li><p>Your app should run on Ruby 1.9.2 (the Celadon
Cedar stack, doesn't support Ruby 1.8.x).</p></li>
<li><p>Your <code>rake assets:precompile</code> task should (ideally) not invoke any database related
operations.</p></li>
<li><p>You should use PostgreSQL as your local development database to
avoid potential differences between the production and the development
database.</p></li>
<li><p>You should add the <code>heroku</code> gem to your <code>Gemfile</code>.</p></li>
<li><p>You should install the <code>taps</code> gem if you'd like to use <code>heroku
db:pull</code> or <code>heroku db:push</code>.</p></li>
</ul>


<h2>Preparations</h2>

<h4>Configure CarrierWave to use cloud storage</h4>

<p>Here's a sample <strong>carrierwave.rb</strong>, that you can put in <strong>config/initializers/</strong> folder:</p>

<p>``` ruby config/initializers/carrierwave.rb
if Rails.env.test? # Store the files locally for test environment
  CarrierWave.configure do |config|</p>

<pre><code>config.storage = :file
config.enable_processing = false
</code></pre>

<p>  end
end</p>

<p>if Rails.env.development? or Rails.env.production? # Using Amazon S3 for Development and Production
  CarrierWave.configure do |config|</p>

<pre><code>config.root = Rails.root.join('tmp')
config.cache_dir = 'uploads'

config.storage = :fog
config.fog_credentials = {
    :provider =&gt; 'AWS', # required
    :aws_access_key_id =&gt; 'key_id', # required
    :aws_secret_access_key =&gt; 'access_key', # required
}
config.fog_directory = 'empoweronrails' # required
</code></pre>

<p>  end
end
```</p>

<h4>Disable db access during rake assets:precompile</h4>

<p>Some gems (like Rails Admin) access the database during the
initialization of the app. The app initialization is ran by default
when you invoke:</p>

<p><code>rake assets:precompile</code></p>

<p>This is not a problem on your development machine, but it's
problematic on Heroku, since the regular database.yml is discarded
there. Add this:</p>

<p><code>config.assets.initialize_on_precompile = false</code></p>

<p>somewhere near the end of your <strong>application.rb</strong> file and it will
suppress the initialization on precompile.</p>

<h4>Enable assets compilation</h4>

<p>It's absolutely required to have this line:</p>

<p><code>config.assets.compile = true</code></p>

<p>in your <strong>production.rb</strong> file if you want your assets to be compiled
automatically by Heroku (which I highly recommend).</p>

<h4>Use thin or unicorn as the application server</h4>

<p>By default, your app's web process runs <code>rails server</code>, which uses
Webrick. This is fine for testing, but for production apps you`ll want
to switch to a more robust webserver. I personally use Thin
(recommended by Heroku). Add this to your Gemfile:</p>

<p><code>gem 'thin'</code></p>

<p>and this to your Procfile (create it if it doesn't already exist):</p>

<p><code>web: bundle exec rails server thin -p $PORT</code></p>

<p>The creation of the Procfile is very important! You can use the
<a href="https://github.com/ddollar/foreman">foreman</a> gem to test the
correctness of the Procfile locally.</p>

<p>Alternatively you can use unicorn. While I haven't used Cedar with
Heroku yet, I've read some nice articles, like this
<a href="http://michaelvanrooijen.com/articles/2011/06/01-more-concurrency-on-a-single-heroku-dyno-with-the-new-celadon-cedar-stack/">one</a>,
according to which one can gain significant performance boost with
unicorn.</p>

<h4>Optimize your slug's size</h4>

<p>Your slug size is displayed at the end of a successful compile. You
can roughly estimate slug size locally by doing a fresh checkout of
your app, deleting the <code>.git</code> directory, and running <code>du -hsc</code>.</p>

<p>Smaller slugs can be transferred across the dyno grid more quickly,
allowing for a faster spin-up speed on your dynos. Generally speaking,
any slug under 15MB is small and nimble; 30MB is average; and 40MB or
above is weighty. If you find your app getting into the 40MB+ range,
you may want to look into some techniques (such as removing unneeded
dependencies or excluding files via <code>.slugignore</code>) to reduce the size.</p>

<p>If your repository contains files not necessary to run your app, you
may wish to add these to a <code>.slugignore</code> file in the root of your
repository.</p>

<h2>Deployment</h2>

<p>First you should create a Heroku application on the Cedar Celadon stack.</p>

<p><code>heroku create --stack cedar</code></p>

<p>This step will automatically add a git remote called <strong>heroku</strong> to
your git repo's config. Afterwards the deployment is as simple as
pushing a branch (e.g. <strong>master</strong>) to this remote:</p>

<p><code>git push heroku master</code></p>

<p>Keep in mind that one Heroku app corresponds to exactly one git
branch. We keep a <strong>production</strong> branch for production deployments and
a <strong>master</strong> branch for development deployments.</p>

<p>The last step is to initialize your database. You have two options -
you can either load the db schema or push an existing database:</p>

<p><code>heroku run rake db:schema:load</code></p>

<p>or</p>

<p><code>heroku db:push</code></p>

<p><code>db:push</code> takes as an optional parameter the URL of the db to push to
heroku in the following format
<code>db://username:password@host/dbname</code>. For example the url for a local
SomeApp db is probably
<code>postgres://someapp:someapp@localhost/someapp</code>. If you
don't supply the URL it will be automatically conjured by inspecting
the <strong>database.yml</strong> file of the project you were in, while issuing the
command.</p>

<h2>Troubleshooting</h2>

<p>If you're lucky your deployment will go without a hitch and you
won't have to ever read this section of the manual. Most people won't
be so lucky. :-)</p>

<h4>Errors during deployment</h4>

<p>If you get an error during the deployment process the cause of the
problem will be in front of your eyes. Never-the-less here are some of
the most common problems:</p>

<ul>
<li>missing Gemfile.lock</li>
<li>Gemfile.lock that doesn't match the project's Gemfile (this happens if you have OS specific gems in your Gemfile)</li>
<li>db access on <code>assets:precompile</code></li>
<li>you forgot the run all specs and cucumber scenarios before
deployment ;-)</li>
</ul>


<h4>Other errors</h4>

<p>Obviously you need to take a look at the stack trace to gain some
insight about the nature of the problem. You can do this very easy:</p>

<p><code>heroku logs</code></p>

<p>Some of the most common errors you'll encounter:</p>

<ul>
<li>you forgot to run some migration(s)</li>
<li>you forgot to turn on asset compilation</li>
<li>you forgot to run all specs and cucumber scenarios before the deployment</li>
</ul>


<h2>Misc</h2>

<h4>Dealing with the database on Heroku</h4>

<p>You can easily apply migrations to the production database. Just run:</p>

<p><code>heroku run rake db:migrate</code></p>

<p>If you want to retrieve the production database locally use the following command:</p>

<p><code>heroku db:pull postgres://username:password@localhost/dbname</code></p>

<p>If you want to push your local db to production run the following command:</p>

<p><code>heroku db:push</code></p>

<p>Be very careful about the last command! <strong>It will wipe out and replace the current production database!</strong></p>

<h4>Running a console</h4>

<p>Running the Rails console on Heroku is astonishingly easy. Just run:</p>

<p><code>heroku run rails console</code></p>

<h2>Epilogue</h2>

<p>Heroku and Rails are moving targets, which causes a bit of a headache
from time to time. Hopefully this short article will save some of you
some of that headache.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django 1.3 vs Rails 3: A not so final showdown]]></title>
    <link href="http://bbatsov.github.com/articles/2011/06/19/django-vs-rails/"/>
    <updated>2011-06-19T00:00:00+03:00</updated>
    <id>http://bbatsov.github.com/articles/2011/06/19/django-vs-rails</id>
    <content type="html"><![CDATA[<h2>Prelude</h2>

<p>I've recently started a new job at an American start-up company. My
position in the company is the one of Technical Lead - the person responsible for
the selection of technologies around which the projects are being
built. Since we'll be doing mostly web development we've had a long
kick-off discussion with the company's CTO about the direction which we should
initially take. He had PHP in mind, but I convinced him that Ruby or
Python would make much better platforms for our futures apps. So he
tasked me to research the two leading frameworks in the Ruby and
Python land - namely Ruby on Rails 3 and Django 1.3. I had a week to
prepare some prototypes with both and create on overview for my
boss. I had some experience with Rails 2 a few years back and I have
fairly decent knowledge of Ruby. My Python is not as fluent
(admittedly), but still - I've played a lot with Python
recently. Django, however, was completely new to me. In this article
I'll try to compare the frameworks in a totally friendly way; if
you've expected an epic flame war post you may very well stop reading
here. I'm obviously no Rails/Django guru, so if I've
written something that is wrong - please feel free to correct me.</p>

<p>Please, keep in mind that a short comparison article cannot even begin
to scratch the immense power and complexity of such frameworks. The overview,
that you'll find here is a bit on the superficial side, but it should
give you enough pointers to get you started.</p>

<p>Hopefully this article will be useful to people that are in the same
boat as was - picking between Rails and Django.</p>

<!--more-->


<h2>Setup &amp; Getting started</h2>

<h3>Rails</h3>

<h4>Linux &amp; OSX</h4>

<p>The recommended (by me) way to install Ruby and Ruby on Rails 3.x is via
<a href="https://rvm.beginrescueend.com/">RVM</a>. RVM allows you to have several
version of Ruby installed at the same time and to easily switch
between them. It also allows you to create gem sets, which are quite
handy in testing. After you've installed RVM it's easy to install any
Ruby interpreter and Rails. This example shows how to get RVM, MRI 1.9.2
and Rails current (3.0.9):</p>

<p><code>bash
$ bash &lt; &lt;(curl -s https://rvm.beginrescueend.com/install/rvm)
$ echo '[[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;&amp; . "$HOME/.rvm/scripts/rvm" # Load RVM function' &gt;&gt; ~/.bash_profile
$ source ~/.bash_profile
$ rvm install 1.9.2
$ rvm use 1.9.2 --default
$ which ruby
~/.rvm/rubies/ruby-1.9.2-p180/bin/ruby
$ ruby -v
ruby 1.9.2p180 (2011-02-18 revision 30909) [i686-linux]
$ gem install rails
$ rails -v
Rails 3.0.9
</code></p>

<p>Since RVM builds Ruby environments from source you might need to
install a few dependencies first. After you've install RVM it will
output those packages as instructions.</p>

<p>If you're using Z Shell (like me) you should replace .bash_profile
with .zshenv or .zshrc.</p>

<h4>Windows</h4>

<p>While there are many ways to get Ruby on Rails installed on a Windows
host, the simplest is certainly to use the <a href="http://railsinstaller.org/">RailsInstaller</a>. It has only one
little drawback - currently it comes with Ruby 1.8.7 bundled, but the
recent beta already features Ruby 1.9.2.</p>

<h4>Your first Rails app</h4>

<p>``` bash
$ rails new railsdemo</p>

<pre><code>  create
  create  README
  create  Rakefile
  create  config.ru
  create  .gitignore
  create  Gemfile
  create  app
  create  app/controllers/application_controller.rb
  create  app/helpers/application_helper.rb
  create  app/mailers
  create  app/models
  create  app/views/layouts/application.html.erb
  create  config
  create  config/routes.rb
  create  config/application.rb
  create  config/environment.rb
  create  config/environments
  create  config/environments/development.rb
  create  config/environments/production.rb
  create  config/environments/test.rb
  create  config/initializers
  create  config/initializers/backtrace_silencers.rb
  create  config/initializers/inflections.rb
  create  config/initializers/mime_types.rb
  create  config/initializers/secret_token.rb
  create  config/initializers/session_store.rb
  create  config/locales
  create  config/locales/en.yml
  create  config/boot.rb
  create  config/database.yml
  create  db
  create  db/seeds.rb
  create  doc
  create  doc/README_FOR_APP
  create  lib
  create  lib/tasks
  create  lib/tasks/.gitkeep
  create  log
  create  log/server.log
  create  log/production.log
  create  log/development.log
  create  log/test.log
  create  public
  create  public/404.html
  create  public/422.html
  create  public/500.html
  create  public/favicon.ico
  create  public/index.html
  create  public/robots.txt
  create  public/images
  create  public/images/rails.png
  create  public/stylesheets
  create  public/stylesheets/.gitkeep
  create  public/javascripts
  create  public/javascripts/application.js
  create  public/javascripts/controls.js
  create  public/javascripts/dragdrop.js
  create  public/javascripts/effects.js
  create  public/javascripts/prototype.js
  create  public/javascripts/rails.js
  create  script
  create  script/rails
  create  test
  create  test/fixtures
  create  test/functional
  create  test/integration
  create  test/performance/browsing_test.rb
  create  test/test_helper.rb
  create  test/unit
  create  tmp
  create  tmp/sessions
  create  tmp/sockets
  create  tmp/cache
  create  tmp/pids
  create  vendor/plugins
  create  vendor/plugins/.gitkeep
</code></pre>

<p>$ rails s
```</p>

<p>As you can see the structure of a Rails project consists of quite a
few folders and files. This is a bit intimidating at first, but
becomes quite valuable once you've used to the predefined
structure. You'll find a good overview of the structure <a href="http://ruby.railstutorial.org/book/ruby-on-rails-tutorial#sec:the_first_application">here</a>.</p>

<p>Open your browser and type
<a href="http://localhost:3000">http://localhost:3000</a> as the url. If
everything is OK you'll see a Rails welcome page.</p>

<p>At this point you should probably either start playing with
scaffolding or read the rest of this article and start playing with
scaffolding afterwards :-) For instance you can try:</p>

<p><code>bash
$ rails g scaffold User first_name:string last_name:string email:string password:string
$ rake db:migrate
$ rails s
</code></p>

<p>Open your browser and type
<a href="http://localhost/users:3000">http://localhost:3000</a> as the
url. "Magic" like this made Rails famous originally.</p>

<p>By default Rails apps use SQLite as a database backend, so might have
to install it as well.</p>

<p>The rails script is useful for various tasks - code generation,
plug-in installation, running a rails console, running a development
web server, etc.</p>

<h2>Django</h2>

<h4>Linux</h4>

<p>I prefer to install django from the distribution's package manager. On
a Red Hat distro like Fedora I would do:</p>

<p><code>bash
$ sudo yum install Django
</code></p>

<p>And on a Debian system:</p>

<p><code>bash
$ sudo apt-get install python-django
</code></p>

<p>A popular alternative (that would work for OSX and Windows users as
well) to this distro-specific approach is to use a
python package manager like <a href="http://packages.python.org/distribute/easy_install.html">easy_install</a> or <a href="http://pypi.python.org/pypi/pip">pip</a>.</p>

<h4>Windows</h4>

<p>The <a href="http://bitnami.org/stack/djangostack">Bitnami Django stack</a> is the simplest way to get Django and
everything that it requires in a single step.</p>

<h4>Your first app</h4>

<p><code>bash
$ django-admin startproject djangodemo
$ ll djangodemo
total 16
-rw-r--r-- 1 bozhidar bozhidar    0 Jun 19 09:45 __init__.py
-rwxr-xr-x 1 bozhidar bozhidar  503 Jun 19 09:45 manage.py*
-rw-r--r-- 1 bozhidar bozhidar 5039 Jun 19 09:45 settings.py
-rw-r--r-- 1 bozhidar bozhidar  577 Jun 19 09:45 urls.py
$ cd djangodemo
$ ./manage.py runserver
</code></p>

<p>Compared to Rails, Django created a much simpler project
structure. There are only four files in here and only two are actual
Django configuration files - settings.py and urls.py. manage.py is
just a script useful for managing some aspects of the project (similar
to the rails script) - it can sync the model with the database, run a
development web server, run a django console, etc.</p>

<p>To test the new project open
<a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a> in your browser.</p>

<h2>Features at a glance</h2>

<h3>Rails</h3>

<h4>Convention over configuration</h4>

<p>The centerpiece of Rails's philosophy is called convention over
configuration(CoC). This basically means that a Rails project has a
predefined layout and sensible defaults. All components (models,
views, controllers, layouts, css, javascript, etc) have standard
places where you should drop them and the application picks them up without
any additional effort on your part.</p>

<p>People seem to underestimate the importance of CoC in practice
initially - it
makes it a lot easier to reason about a project and a lot easier to
configure the project. On the other hand if some of the defaults don't
work for you - you'd have to jump through some hoops. Recent versions
of Rails, however, have made it a lot easier to tweak the defaults.</p>

<p>All in all I feel that CoC is a big win for developers and I guess
many people share my opinion since CoC can now be found in many other
frameworks as well.</p>

<h4>MVC to the bone</h4>

<p>Rails is a classical Model-View-Controller full stack web framework -
it handle all aspects of a typical web application. What separates it
from most of the MVC frameworks around is the heavy emphasis on
<a href="http://en.wikipedia.org/wiki/Representational_State_Transfer">REST</a>. The
domain objects are treated as resources and could be handled in a
uniform manner using just the standard HTTP verbs like GET, PUT,
DELETE, POST. REST is extremely good fit for data driven applications.</p>

<p>As usual the model houses the application's business logic, the
controller invokes functionality from the model layer and feeds the
resulting data to the view layer, which display the data in a
meaningful way to the user.</p>

<p>The model layer is the home of your domain objects and the business
logic surrounding them. Domain objects (a.k.a. entities) are mapped to
database tables (at least in RDBMS). Unlike most object relational
mappers Rails's ActiveRecord (the default ORM; could be substituted
with something else if you wish) doesn't require you to explicitly
declare the structure of the objects, but rather extracts it
automatically from your DB table definitions. A simple class, modeling
an application user might look like this:</p>

<p><code>bash
class User &lt; ActiveRecord::Base
  validates :first_name, :last_name, :email, :password, :presence =&gt; true
  validates :password, confirmation: true
end
</code></p>

<p>Note that the validation methods are entirely optional (but highly
recommended) - the class could have very well had an empty body. Rails
would know to look for a table named Users in the database and extract
the field information from it.</p>

<p>Rails generates automatically for us "finders" that we can use to make
queries about objects in pure Ruby. It also provides an elegant DSL to
express relationships between various model classes (belongs_to,
has_many, etc)</p>

<p>In the view layer Rails has traditionally relied on HTML templates
with Ruby code embedded in them (html.erb). There are a lot of
community contributed alternatives, however, with HAML being the most
prominent one. On a similar note Rails allows you to use SASS as a
replacement for traditional CSS.</p>

<p>Another centerpiece in Rails is the "Don't Repeat Yourself"(DRY)
principle. In the view layer partial templates, layouts and helpers
are some of the tools available to help you abide by that
principle. You'll certainly make heavy use of them in your
applications so you should pay them some special attention.</p>

<h4>Database migrations</h4>

<p>Everyone that has done some serious programming knows that it's not
realistic to presume that the initial database schema won't ever
change - fields get added/removed, new tables get introduced,
etc. All those changes are commonly referred to as "migrations" and
traditionally every team unrolls its own handling of the problem. On
my last job I was tasked at some point to write a tool in Java that
analyzed a config file and a directory structure filled with SQL
scripts and applied them selectively to various target databases. In
Rails you get this functionally for free - you can express your
migrations as simple Ruby scripts and you can use rake to generate the
appropriate SQL statements for any supported database. Here's a simple
migration script, that creates the Users table:</p>

<p>``` ruby
class CreateUsers &lt; ActiveRecord::Migration
  def self.up</p>

<pre><code>create_table :users do |t|
  t.string :first_name
  t.string :last_name
  t.string :email
  t.string :password

  t.timestamps
end
</code></pre>

<p>  end</p>

<p>  def self.down</p>

<pre><code>drop_table :users
</code></pre>

<p>  end
end
```</p>

<p>The up method gets invoked when the migration is applied and the down
method gets invoked when it's reverted. Rails 3.1 will offer even more
elegant migrations. To execute all migrations:</p>

<p><code>bash
$ rake db:migrate
</code></p>

<h4>Ajax from within</h4>

<p>Rails features tight integration with JavaScript and AJAX. Versions
prior to 3.1 shipped by default the prototype and scriptaculous
JavaScript libraries. In
version 3.1 jQuery will replace them as the default JavaScript
library.</p>

<p>Making and handling AJAX requests in Rails is generally very easy - a
big advantage in today world ruled by rich and dynamic web UIs.</p>

<h4>Extensibility</h4>

<p>Rails is extendable through a multitude of community supplied plugins
that could add incredible functionality to your apps for free. Some of
my favorite plugins are <a href="https://github.com/indirect/jquery-rails">jQuery for Rails</a>,
<a href="https://github.com/bcardarella/client_side_validations">client side validations</a> and <a href="https://github.com/sferik/rails_admin">Rails Admin</a>.</p>

<h4>Testing is not optional</h4>

<p>What I particularly like about Rails is that it heavily promotes
testing your code. All of the Rails generators would generate test
stubs, that you'll do good to fill in. Rails supports all major Ruby test
frameworks - Test::Unit, RSpec, Cucumber. You have fixtures support, test
database support, the ability to run unit and functional test
separately. I don't recall using any other framework that pays as much
attention to having tests as Rails and for that I can only
congratulate the Rails team.</p>

<h4>Compatibility with Ruby versions</h4>

<p>There are two major version of Ruby out there presently - Ruby 1.8.7
and Ruby 1.9.2. Ruby 1.9.2 offers substantial language and performance
improvements, so you should be pleased to hear that Rails supports
both major Ruby versions. Rails 4.0 will drop support for Ruby 1.8.x.</p>

<p>Rails can also be run on top of JRuby and Rubinius.</p>

<h4>Deployment options</h4>

<p>The most common deployment options for Rails are currently Apache
HTTPD or NginX and Phusion Passenger (mod_rails). People shopping for
cloud Rails deployment should definitely take a look at Heroku.</p>

<p>Rails also runs on alternative Ruby implementations like JRuby and
Rubinius (as mentioned above), that offer exciting new possibilities. For instance using
JRuby allows you to deploy a Rails app into a Java application server
like JBoss or Glassfish and to tap into all those great Java libraries
and frameworks around. Using JRuby also gives you the opportunity to
deploy your apps on Google's App Engine.</p>

<h3>Django</h3>

<h4>A simpler project layout</h4>

<p>While I had some experience with Rails from a couple of years ago,
Django was something totally new to me. I expected it to be more or
less Rails for Python, but when I created my first Django app I was
surprised to see that the project folder consisted of only three
files (I'm obviously not counting the python package file
<strong>init</strong>.py).</p>

<p>My initial surprise aside it turned out that most differences were
just superficial and that Django and Rails have quite a lot of
similarities. I'll, however, speak a bit more about the different
stuff than the similar stuff.</p>

<h4>MVC(MTV), Django style</h4>

<p>While Django is a MVC controller framework as well, it's built around a
different mindset. Django is totally configurable and minimalistic
framework that empowers the developers to tailor it to their needs.</p>

<p>A Django project is comprised of autonomous and reusable apps. Apps on
the other hand are comprised of models, views and templates. Django
differs a bit in terminology with Rails - the Rails controllers are
views in Django and the Rails views are called templates in Django. You
can sometimes hear that Django is a Model-Template-View framework -
that shouldn't confuse you. Although the terminology is different the
principles are the same.</p>

<p>Django's default ORM is somewhat reminiscent of frameworks like
Hibernate. Entity classes declare explicitly the all the
attributes. Let's consider again the User model class:</p>

<p>``` python
from django.db import models</p>

<p>class User(models.Model):</p>

<pre><code>first_name = models.CharField(max_length=30)
last_name = models.CharField(max_length=30)
email = models.EmailField()
password = models.CharField(max_length=30)
</code></pre>

<p>```</p>

<p>Both approaches have their strengths and weaknesses an usual. In
Django's case we have increased verbosity, but on the other had we
don't have to inquire the database to figure out the exact definition
of model records.</p>

<p>Like in Rails we get useful "finders" that can be used to query for model
objects in pure python (as opposed to using sql).</p>

<h4>In the template layer</h4>

<p>While ERB is basically HTML with Ruby embedded in it, Django features
a custom templating language with it's own (extendable) tag
library. This generally means that Django templates tend to be a bit
cleaner than Rails's templates, since you're not allowed to abuse them
very much. On the other hand you can do virtually anything by
embedding code directly in a template, so as usual - each design
decision has its pros and cons.</p>

<p>Django supports alternative templating libraries, so you're covered in
case you don't like the default one.</p>

<p>Django also features a powerful form generation/handling facilities
that integrate seamlessly with the templating layer. For instance - it
very easy to generate a form matching the structure of a domain model
object with automatic property validation.</p>

<h4>You're in charge</h4>

<p>Django has doesn't adhere to the Rails CoC philosophy. It's assumed
that developers know best what layout and configurations options make
the most sense in their applications. I haven't played that much with
Django yet, but I still haven't come by two different Django apps that
are structured in the same manner. While I understand the benefits of
Django's approach I still prefer Rails's approach. I've worked long
enough to know that you're rarely in the position to make better
decisions about the structure and the defaults of your app, than the
exceptional developers with huge experience that develop frameworks
like Rails and Django.</p>

<p>To illustrate this consider the strong emphasis Rails places on
REST. In Django you could certainly use restful access your resources
as well, but it's all up to you. The framework makes no
suggestions. You can unroll any URL mapping scheme by simply
associating regular expressions in urls.py with callback view
functions:</p>

<p><div>
  <pre><code class='python'>from django.conf.urls.defaults import patterns, include, url&lt;/p&gt;

&lt;p&gt;urlpatterns = patterns('',&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;url(r'^$', 'djangodemo.views.home', name='home')
url(r'^users', 'djangodemo.view.users', name='list_users'))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p>An url is mapped to the callback function, which in turn either renders a
template or directly returns some Http response.</p>

<h4>Free admin</h4>

<p>Django has a built-in support to generate an admin UI for your
website. This is a very useful feature indeed and is supported in
Rails as well through plugins (I've mentioned the one I like the
best).</p>

<h4>Database migrations</h4>

<p>One of the few gripes I have with stock Django is that it doesn't
offer an alternative to Rails's migrations. Luckily there is
<a href="http://south.aeracode.org/">South</a> - an extension that provides a
simple, stable and database-independent migration layer to prevent all
the hassle schema changes over time bring to your Django
applications. I highly recommend it to everyone planning to use
Django.</p>

<h4>JavaScript and AJAX</h4>

<p>Unlike Rails, Django doesn't bundle any JavaScript libraries. You have
to pick a JavaScript framework yourself (which a trivial process). The
AJAX support in Django is both basic and extremely powerful in the
same time - request.is_ajax(). What this means is that you can check
if a request was regular or an AJAX request and respond
accordingly. You don't need much more than that. More details can be
found <a href="https://code.djangoproject.com/wiki/AJAX">here</a>.</p>

<h4>The great divide</h4>

<p>Some of you probably know that Python is currently at a bit of a
crossroads. Python 2.x was the stable Python version for many years,
but recently it was replaced by Python 3.x. Python 3.x is all around
great in my personal opinion, but unfortunately it's backward
incompatible with the older 2.x series. For that reason very few high
profile projects still don't support it - Django is one such
project. The current version 1.3 require at least Python 2.4 and will
run with every Python up to 2.7. This is a bit of a disappointment
since you'll be missing on a few very cool new features. On a more
positive note Python 2.7 did backport some goodies from Python 3, so
not all is lost. I've read (at totally unofficial places) that Django 2.0 will be targeting Python 3
and I expect it will be available in about a year.</p>

<h4>Deployment</h4>

<p>Python is quite mature technology and offers you a nice array of
deployment options - Apache, Nginx and my favorite - Google App
Engine. Python, being one of the two supported languages on the App
Engine (the other one is, of course, Java) makes it very easy to deploy
Django apps on the App Engine (though you'll need the Django support
for non-relational databases to be able to use it).</p>

<p>The also the possibility to deploy Django apps on Java or .Net
infrastructure using Jython or IronPython.</p>

<h2>Community</h2>

<p>When you're selecting the technology for a major project you have to
make sure that the technology is in good shape - there is a solid
community around it, there is no lack of support, innovation and
deployment options.</p>

<p>Both
<a href="http://www.google.com/trends?q=ruby+on+rails%2C+django+python">Google trends</a>
and stackoverflow.com (by the number of question about tagged with
django or rails) indicate that Rails currently has larger
community than Django.</p>

<p>I haven't had any direct communication with the Django community yet,
but I've found a lot of excellent resources about Django on-line.</p>

<p>Rails has one of the most vibrant, passionate and innovative
communities. I've had contact with a lot of people from the Rails
community and I'm certain that it has played a tremendous role in
Rails's growth.</p>

<h2>Tooling</h2>

<p>Traditionally Ruby &amp; Python hackers have been working with just a
powerful programmer's editor like Emacs, vim or TextMate. While there
is nothing inherently wrong with this approach (I'm an avid Emacs user
myself), I do find IDEs quite helpful when working on larger code
bases, with their trademark features such as intelligent
autocompletion (aka intellisense), safe refactorings, on-the-fly syntax checking, etc. So
here's what we've got:</p>

<ul>
<li><a href="http://www.jetbrains.com/ruby/">RubyMine</a> - hands down the best Ruby and Rails IDE I've ever
used. The <a href="http://www.jetbrains.com/ruby/features/index.html">list of features</a> is epic as is the quality of the
project. It support Rails 3, git, RSpec, Cucumber, sass, haml and
many other cool Ruby/Rails related technologies. Sure, it's a
commercial project, but is priced very reasonably.</li>
<li><a href="http://www.aptana.com/">Aptana Studio</a> - a Web development IDE,
built on top of the Eclipse platform. Among many other features it
supports Ruby on Rails.</li>
<li><a href="http://www.activestate.com/komodo-ide">Komodo</a> - an IDE focusing on
dynamic programming language. Great support for both Django and
Rails development.</li>
<li><a href="http://www.jetbrains.com/pycharm/">PyCharm</a> - from the same company that develops RubyMine, PyCharm
is the king of IDEs when it comes down to Python. It has full
featured Django support - there is even autocompletion in the Django
templates.</li>
<li><a href="http://pydev.org/">PyDev</a> - an Eclipse plug-in for Python and Django development.</li>
</ul>


<p>I have to admit I'm totally biased. Having been a long time Java
developer I've grown extremely fond of the exceptional IntelliJ
IDEA. RubyMine and PyCharm are both based on the IntelliJ platform and
bring to the Ruby and Python developers much of the might and magic of
IDEA. There are both commercial products, but their price tags are
quite low and their quality is great - highly recommended.</p>

<p>I'm not affiliated in any way with any of these products - I just
happen to like them that much.</p>

<h2>Resources</h2>

<p>The are LOTS of resources about Rails and Django on-line. Here are
just my favorites.</p>

<h4>Rails</h4>

<ul>
<li><a href="http://guides.rubyonrails.org/">Rails Guides</a> - best short
introduction to Rails ever. Immediately updated for new Rails
versions, fantastic starting point for any aspiring Rails developer.</li>
<li><a href="http://ruby.railstutorial.org/">Rails Tutorial</a> - best Rails 3 book
on the market and it even has a free on-line edition. Nice follow up
of the Rails Guides.</li>
<li><a href="http://railscasts.com/">RailsCasts</a> - Ryan Bates in true Ruby
hero. He has compiled a unique set of high quality Rails screencasts
that often illustrate some advanced techniques. And they are all
free. We all owe a very big "Thanks!" to Ryan.</li>
</ul>


<h4>Django</h4>

<ul>
<li><a href="https://docs.djangoproject.com/en/1.3/">Official Docs</a> - best
official project documentation I've read. It's actually so good,
that I never (well - almost never) bothered to look for anything else. All my questions
were answered by the official documentation.</li>
</ul>


<h2>Epilogue</h2>

<p>Choosing Django or Rails is basically a win-win situation - you cannot
go wrong. There are too many similarities between the frameworks and
the differences are not something paramount.</p>

<p>Rails places a heavy emphasis on convention over configuration,
provides you with more defaults and does a can do a lot of heavy
lifting for you automagically.</p>

<p>Django on the other hand let's you specify most configuration details
yourself, without making the configuration burdensome (like that of
older Java web frameworks).</p>

<p>Rails has always been leading on the way of innovation - constantly
integration some of the latest and greatest technologies around
(recent examples being jQuery, Coffee Script and SASS). From time to
time backward compatibility is sacrificed for the greater good, so
that is something that you should consider as well.</p>

<p>Django is certainly much more conservative framework as far as
backward compatibility is concerned - after all it still support
Python 2.4.</p>

<p>I guess in the end the choice really boils down to two things - whether you
like Ruby or Python better and whether you like the defaults imposed
to you by Rails.</p>

<p>I've planned to write a much longer and detailed article, but it's
summer here and it's sunday and I'd rather go out and drink a few
beers with my friends. Hopefully you've enjoyed the article. I'll try
to expand it a bit in the coming days.</p>

<p>P.S. Btw, in case you're wondering - we've picked Rails for our
company's projects. It was a very close call, though, since I
really liked a lot of aspects of Django as well.</p>
]]></content>
  </entry>
  
</feed>
