<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Style | (think)]]></title>
  <link href="http://bbatsov.github.com/articles/categories/style/atom.xml" rel="self"/>
  <link href="http://bbatsov.github.com/"/>
  <updated>2013-07-01T18:31:11+03:00</updated>
  <id>http://bbatsov.github.com/</id>
  <author>
    <name><![CDATA[Bozhidar Batsov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Elements of Style in Ruby #4: Array#join vs Array#*]]></title>
    <link href="http://bbatsov.github.com/articles/2013/07/01/the-elements-of-style-in-ruby-number-4-array-number-join-vs-array-number-star/"/>
    <updated>2013-07-01T16:28:00+03:00</updated>
    <id>http://bbatsov.github.com/articles/2013/07/01/the-elements-of-style-in-ruby-number-4-array-number-join-vs-array-number-star</id>
    <content type="html"><![CDATA[<p>Today's topic is the following rule from the <a href="https://github.com/bbatsov/ruby-style-guide">Ruby Style Guide</a>:</p>

<blockquote><p>Favor the use of <code>Array#join</code> over the fairly cryptic <code>Array#*</code> with
a string argument.</p></blockquote>

<p><code>Array#join</code> and <code>Array#*</code> (with a string argument) behave exactly the same:</p>

<p>``` ruby
%w(Bruce Wayne).join(' ')</p>

<h1>=> "Bruce Wayne"</h1>

<p>%w(Bruce Wayne) * ' '</p>

<h1>=> "Bruce Wayne"</h1>

<p>```</p>

<p>So, considering they both do the same thing why should you opt to use
<code>join</code> instead of <code>*</code>? Here's a few reasons:</p>

<ul>
<li><code>*</code> behaves totally differently when passed an integer argument:</li>
</ul>


<p>``` ruby
[1 2] * 3</p>

<h1>=> [1 2 1 2 1 2]</h1>

<p>```</p>

<p>Personally, I'd expect this to be only behavior of such an operator
method and find the alternative one (with a string argument) to be
pretty much counter-intuitive.</p>

<ul>
<li>It's not always clear what <code>*</code> means without additional
context. Take a look at this short snippet:</li>
</ul>


<p>``` ruby</p>

<h1>a and b are variables</h1>

<p>a * b
```</p>

<p>Without some knowledge of <code>a</code> and <code>b</code> we cannot be certain what this
code is going to do. It's hard even to speculate what the code is
going to do. Obviously better variable names would certainly help, but
the point still stands.</p>

<p><code>
a.join(b)
</code></p>

<p>While we still cannot be absolutely certain, it's highly likely that <code>a</code> is
an <code>Array</code> and <code>b</code> is a <code>String</code>.</p>

<ul>
<li><code>*</code> does not carry much of a semantic value in it.</li>
</ul>


<p>Unlike <code>String#%</code>, <code>Array#*</code> with a string argument carries pretty
much no meaning. It's absolutely beyond me how this came into
existence. On the other hand the behavior of <code>Array#*</code> with an integer
argument is pretty reasonable. Here we see a classic example of the
notion that too much operator overloading can be a bad thing, leading
to some pretty unreadable code. An operator should be employed only
when it's use would add clarity to the code, not take clarity away.</p>

<p><code>Array#*</code> has one thing going for it, however - the fact that few
people know about its use as a substitute for <code>Array#join</code>. I hope
they realize that some unknown features are unknown for a reason -
because it's bad idea to make use of them.</p>

<p>As usual I'm looking forward to hearing your thoughts here and on
<a href="http://twitter.com/bbatsov">Twitter</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Elements of Style in Ruby #3: Make sure something is an array]]></title>
    <link href="http://bbatsov.github.com/articles/2013/06/28/the-elements-of-style-in-ruby-number-3-make-sure-something-is-an-array/"/>
    <updated>2013-06-28T15:39:00+03:00</updated>
    <id>http://bbatsov.github.com/articles/2013/06/28/the-elements-of-style-in-ruby-number-3-make-sure-something-is-an-array</id>
    <content type="html"><![CDATA[<p>The subject of today's post is the following rule from the
<a href="https://github.com/bbatsov/ruby-style-guide">Ruby Style Guide</a>:</p>

<blockquote><p>Use <code>[*var]</code> or <code>Array()</code> instead of an explicit <code>Array</code> check, when dealing with a </br>
variable you want to treat as an Array, but you're not certain it's </br>
an array.</p></blockquote>

<p>Countless times I've seen code like this:</p>

<p><code>ruby
paths = [paths] unless paths.is_a? Array
paths.each { |path| do_something(path) }
</code></p>

<p>It seems that <code>paths</code> could be either an <code>Array</code> object or an object
of some other class. The author of the code needed to make sure
<code>paths</code> would be an array so he creates a single element array in the
case <code>paths</code> is not already an array.</p>

<p>While the above code works it's not something an experienced Rubyist
would write. The most popular alternative is the use of the mighty splat
operator(<code>*</code>):</p>

<p><code>ruby
[*paths].each { |path| do_something(path) }
</code></p>

<p>It case you're puzzled by the preceding snippet consider the following example:</p>

<p>``` ruby
elems = 1
[*elems]</p>

<h1>=> [1]</h1>

<p>elems = [1, 2, 3]
[*elems]</p>

<h1>= [1, 2, 3]</h1>

<p>```</p>

<p>Hope that makes clear what's going on.</p>

<p>While I'm extremely fond of this particular usage of <code>*</code> I tend to
avoid it, since there is another equally powerful, but more readable
alternative to it - <code>Kernel#Array</code>. Here's it in action:</p>

<p><code>ruby
Array(paths).each { |path| do_something(path) }
</code></p>

<p><code>Array</code> looks like the name of class, but it's not. It's a totally
normal method defined in the <code>Kernel</code> module. There is a whole family
of conversion methods similar to <code>Array</code> there - <code>Array</code>, <code>Complex</code>,
<code>Float</code>, <code>Hash</code>, <code>Integer</code>, <code>Rational</code> and <code>String</code>. They are all used
for often in practice and we'll probably revisit them in a separate
post somewhere down the road.</p>

<p>The <code>Array</code> method operates exactly like <code>*</code> - it takes a single argument and
converts it to an <code>Array</code> object if necessary:</p>

<p>``` ruby
Array(1)</p>

<h1>=> [1]</h1>

<p>Array([1, 2, 3])</p>

<h1>=> [1, 2, 3]</h1>

<p>```</p>

<p>You can also use <code>*</code> and <code>Array</code> to convert to array other data
composite data structures (like hashes and sets), but that's
irrelevant to today's discussion.</p>

<p>That's all I have for you today, mates. As usual I'm looking forward
to hearing your thoughts here and on
<a href="http://twitter.com/bbatsov">Twitter</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Elements of Style in Ruby #2: Favor sprintf(format) over String#%]]></title>
    <link href="http://bbatsov.github.com/articles/2013/06/27/the-elements-of-style-in-ruby-number-2-favor-sprintf-format-over-string-number-percent/"/>
    <updated>2013-06-27T13:15:00+03:00</updated>
    <id>http://bbatsov.github.com/articles/2013/06/27/the-elements-of-style-in-ruby-number-2-favor-sprintf-format-over-string-number-percent</id>
    <content type="html"><![CDATA[<p>Today's topic is the following rule from the <a href="https://github.com/bbatsov/ruby-style-guide">Ruby Style Guide</a>:</p>

<blockquote><p>Favor the use of <code>sprintf</code> and its alias <code>format</code> over the fairly </br>
cryptic <code>String#%</code> method.</p></blockquote>

<p><code>Kernel#sprintf</code> and <code>String#%</code> basically do the same thing - the main
difference is that <code>sprintf</code> is generally used as a command(it does
not operate on its receiver) and <code>String#%</code> is obviously an instance
method of the class <code>String</code>. Here's the two of them in action:</p>

<p>``` ruby
'%d %d' % [20, 10]</p>

<h1>=> '20 10'</h1>

<p>sprintf('%d %d', 20, 10)</p>

<h1>=> '20 10'</h1>

<p>```</p>

<p>So, considering they both do the same thing why should you opt to use
<code>sprintf</code> instead of <code>%</code>? Here's a few reasons:</p>

<ul>
<li><code>%</code> takes either a single element or an array of elements as its
sole argument; <code>sprintf</code> consistently takes a variable number of
arguments.</li>
</ul>


<p>``` ruby
'%d' % 20</p>

<h1>=> '20'</h1>

<p>'%d %d' % [20, 10]</p>

<h1>=> '20 10'</h1>

<p>sprintf('%d %d', 20)</p>

<h1>=> '20'</h1>

<p>sprintf('%d %d', 20, 10)</p>

<h1>=> '20 10'</h1>

<p>```</p>

<p>Personally, I dislike such inconsistencies a lot.</p>

<ul>
<li>It's not always clear what <code>%</code> means without additional
context. Take a look at this short snippet:</li>
</ul>


<p>``` ruby</p>

<h1>a and b are variables</h1>

<p>a % b
```</p>

<p>Without some knowledge of <code>a</code> and <code>b</code> we cannot know if we're dealing
with a modulo operation (if <code>a</code> and <code>b</code> are fixnums), <code>String#%</code> or if
<code>a</code> is an instance of some other class which has implemented the <code>%</code>
method.</p>

<p>With <code>sprintf</code> it's always crystal-clear what's going on.</p>

<ul>
<li><code>%</code> does not carry much of a semantic value in it.</li>
</ul>


<p>Sure, it was named so because of the <code>%</code> placeholders in the target
string, but people not familiar with that operator will probably be
confused by such odd-looking syntax. <code>sprintf</code> on the other hand is
old as time (so people reading your code have probably encountered it
somewhere before) and beside that it's fairly easy to remember that it
stands for <code>string print formatted</code> (or something similar). On a
related note - the use of <code>Kernel%sprintf</code>'s alias <code>format</code> yields
even better readability, since <code>format</code> is obviously less cryptic name
than <code>sprintf</code> and the same name is employed in many programming
languages (most notably <code>Java</code> and many Lisp dialects).</p>

<p>There's one thing about <code>sprintf/format</code> that I dislike, though. It
doesn't make that much sense to have such an operation as command in a
OO language like Ruby. Alas, those things are not up to me - I guess
the authors had something in mind when they made that particular
decision about the standard library.</p>

<p>In an ideal world the standard library would have included a
<code>String#format</code> method, that took variable number of arguments. For
some reason (unknown to me) - that has not happened (and maybe never
will). For now the use of <code>Kernel#sprintf</code> (and <code>Kernel#format</code>)
yields the best results when it comes down to code clarity and
consistency. I encourage you to use them (<code>format</code> in particular)!</p>

<p>As usual I'm looking forward to hearing your thoughts here and on
<a href="http://twitter.com/bbatsov">Twitter</a>!</p>
]]></content>
  </entry>
  
</feed>
